---
phase: 01-design-system-foundation
plan: 05
type: execute
wave: 3
depends_on: [01-01]
files_modified: [src/components/theme-provider.tsx, src/hooks/use-theme.ts, src/main.tsx]
autonomous: true

must_haves:
  truths:
    - "ThemeProvider component manages theme state with React context"
    - "ThemeProvider supports 'light', 'dark', and 'system' themes"
    - "ThemeProvider syncs theme to localStorage for persistence"
    - "ThemeProvider applies .dark or .light class to documentElement"
    - "System theme detection uses prefers-color-scheme media query"
    - "useTheme hook provides theme and setTheme to consumers"
    - "ThemeProvider wraps App in main.tsx"
  artifacts:
    - path: "src/components/theme-provider.tsx"
      provides: "React context provider for theme management"
      exports: ["ThemeProvider"]
      contains: ["createContext", "useEffect", "localStorage", "classList"]
    - path: "src/hooks/use-theme.ts"
      provides: "Custom hook for accessing theme context"
      exports: ["useTheme"]
    - path: "src/main.tsx"
      provides: "App entry point with ThemeProvider wrapper"
      contains: ["ThemeProvider"]
  key_links:
    - from: "src/hooks/use-theme.ts"
      to: "src/components/theme-provider.tsx"
      via: "useContext hook accessing ThemeProviderContext"
      pattern: "useContext.*ThemeProviderContext"
    - from: "src/components/theme-provider.tsx"
      to: "document.documentElement"
      via: "classList.add/remove for theme class"
      pattern: "root.classList.(add|remove)"
---

<objective>
Create ThemeProvider component and useTheme hook for runtime theme switching with system preference detection and localStorage persistence.

Purpose: Enable users to toggle between light/dark themes, respect system preferences, and persist choice across sessions. This completes the design system foundation by providing the mechanism that makes CSS variables theming useful.

Output: src/components/theme-provider.tsx with context provider, src/hooks/use-theme.ts with custom hook, and ThemeProvider wrapping App in main.tsx.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-design-system-foundation/01-CONTEXT.md
@.planning/phases/01-design-system-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Create ThemeProvider component</name>
  <files>src/components/theme-provider.tsx</files>
  <action>
    Create src/components/theme-provider.tsx with the following implementation:

    ```typescript
    import type React from "react";
    import { createContext, useContext, useEffect, useState } from "react";

    type Theme = "dark" | "light" | "system";

    type ThemeProviderProps = {
      children: React.ReactNode;
      defaultTheme?: Theme;
      storageKey?: string;
    };

    type ThemeProviderState = {
      theme: Theme;
      setTheme: (theme: Theme) => void;
    };

    const initialState: ThemeProviderState = {
      theme: "system",
      setTheme: () => null,
    };

    const ThemeProviderContext =
      createContext<ThemeProviderState>(initialState);

    export const ThemeProvider = ({
      children,
      defaultTheme = "system",
      storageKey = "portfolio-theme",
      ...props
    }: ThemeProviderProps) => {
      const [theme, setTheme] = useState<Theme>(() => {
        return (localStorage.getItem(storageKey) as Theme) || defaultTheme;
      });

      useEffect(() => {
        const root = window.document.documentElement;
        root.classList.remove("light", "dark");

        if (theme === "system") {
          const systemTheme = window.matchMedia(
            "(prefers-color-scheme: dark)"
          ).matches
            ? "dark"
            : "light";

          root.classList.add(systemTheme);
          return;
        }

        root.classList.add(theme);
      }, [theme]);

      const value = {
        theme,
        setTheme: (theme: Theme) => {
          localStorage.setItem(storageKey, theme);
          setTheme(theme);
        },
      };

      return (
        <ThemeProviderContext.Provider {...props} value={value}>
          {children}
        </ThemeProviderContext.Provider>
      );
    };

    export const useTheme = () => {
      const context = useContext(ThemeProviderContext);

      if (context === undefined) {
        throw new Error("useTheme must be used within a ThemeProvider");
      }

      return context;
    };
    ```

    Reference: RESEARCH.md > Pattern 7 for complete example.

    Note: We're exporting both ThemeProvider and useTheme from the same file. The hooks/use-theme.ts in the next task will re-export for cleaner imports.
  </action>
  <verify>grep -E "export.*ThemeProvider|export.*useTheme|createContext.*ThemeProvider" src/components/theme-provider.tsx</verify>
  <done>theme-provider.tsx exports ThemeProvider component and useTheme hook</done>
</task>

<task type="auto">
  <name>Create use-theme.ts hook barrel export</name>
  <files>src/hooks/use-theme.ts</files>
  <action>
    Create src/hooks/use-theme.ts that re-exports useTheme for cleaner imports:

    ```typescript
    export { useTheme } from "@components/theme-provider";
    ```

    This allows consumers to import with `import { useTheme } from "@hooks/use-theme"` instead of importing from components.
  </action>
  <verify>grep "useTheme" src/hooks/use-theme.ts</verify>
  <done>use-theme.ts re-exports useTheme from theme-provider</done>
</task>

<task type="auto">
  <name>Wrap App with ThemeProvider in main.tsx</name>
  <files>src/main.tsx</files>
  <action>
    Edit src/main.tsx to wrap the App component with ThemeProvider:

    Current structure likely looks like:
    ```typescript
    import { StrictMode } from "react";
    import { createRoot } from "react-dom/client";
    import App from "./App.tsx";
    import "./styles/globals.css";

    createRoot(document.getElementById("root")!).render(
      <StrictMode>
        <App />
      </StrictMode>,
    );
    ```

    Change to:
    ```typescript
    import { StrictMode } from "react";
    import { createRoot } from "react-dom/client";
    import { ThemeProvider } from "@components/theme-provider";
    import App from "./App.tsx";
    import "./styles/globals.css";

    createRoot(document.getElementById("root")!).render(
      <StrictMode>
        <ThemeProvider defaultTheme="system" storageKey="portfolio-theme">
          <App />
        </ThemeProvider>
      </StrictMode>,
    );
    ```

    The ThemeProvider must wrap App so all components can access theme context via useTheme hook.
  </action>
  <verify>grep -E "ThemeProvider.*App" src/main.tsx</verify>
  <done>main.tsx wraps App with ThemeProvider</done>
</task>

<task type="auto">
  <name>Test theme switching</name>
  <files>src/App.tsx</files>
  <action>
    Create a simple test in App.tsx to verify theme switching works:

    Add the following code to test theme switching (this is temporary verification code):
    ```typescript
    import { useTheme } from "@hooks/use-theme";

    // Inside App component, before return:
    const { theme, setTheme } = useTheme();

    // In the JSX, add a theme toggle button:
    <button
      onClick={() => setTheme(theme === "light" ? "dark" : "light")}
      className="px-4 py-2 bg-primary text-primary-foreground rounded"
    >
      Toggle theme (current: {theme})
    </button>
    ```

    This allows manual verification that:
    1. useTheme hook works
    2. Theme switches between light/dark
    3. .dark class is applied to html element
    4. CSS variables update (colors change)

    After verification in the next step, this button can be removed or kept as a temporary toggle. A proper theme toggle UI component will be added in a later phase.
  </action>
  <verify>grep -E "useTheme|setTheme" src/App.tsx</verify>
  <done>App.tsx has theme toggle button for testing</done>
</task>

</tasks>

<verification>
After all tasks complete, verify the theme system is working:

1. Run `npm run build` - should succeed
2. Run `npm run lint` - should pass
3. Run `npm run dev` and test:
   - Click the toggle button
   - Check that html element gains .dark class (browser dev tools)
   - Check that colors change (light vs dark background/foreground)
   - Refresh page - theme should persist (localStorage)
   - Set theme to "system" and change OS theme - should update

4. In browser console, verify localStorage has "portfolio-theme" key
5. Verify useTheme throws error when used outside ThemeProvider (create test component without wrapper)

If theme switching doesn't work:
- Check ThemeProvider wraps App in main.tsx
- Check globals.css has .dark selector with color overrides
- Check Tailwind plugin is processing CSS
</verification>

<success_criteria>
1. src/components/theme-provider.tsx exists with ThemeProvider and useTheme
2. src/hooks/use-theme.ts re-exports useTheme
3. main.tsx wraps App with ThemeProvider
4. Theme can be toggled between light/dark
5. Theme persists across page refresh (localStorage)
6. System theme preference is respected when theme="system"
7. .dark class is applied to html element
8. At least one component (Button) has been successfully installed via `npx shadcn add` to verify the infrastructure works
9. npm run build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/01-design-system-foundation/01-05-SUMMARY.md` with:
- ThemeProvider implementation details
- Theme switching verified working
- localStorage persistence confirmed
- Next step: Plan 01-06 will verify component installation works by adding a Button component

NOTE: DS-07 (Composition Pattern) is deferred to later phases because shadcn components use their own patterns (default exports, not project's Composition Pattern per CONTEXT.md decision). The project's Composition Pattern will be applied to custom-built components in Phase 2+.
</output>
